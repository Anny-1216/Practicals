# -*- coding: utf-8 -*-
"""DAA2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HbBTjnZlcsMx39f3YoiOblTSFhHTxmEm
"""

msg=input("Enter Your Msg:")
orignal_length=len(msg)*8

print(f"Orignal Size of Msg ={orignal_length} bits")

my_dict={}
for char in msg:
  my_dict[str(char)]=0

for char in msg:
  my_dict[str(char)]+=1



print(my_dict)

# 1. Define a Node class for the tree
# We no longer need the __lt__ method!
class Node:
    def __init__(self, char, freq, left=None, right=None):
        self.char = char
        self.freq = freq
        self.left = left
        self.right = right

# 2. Create the initial list of leaf nodes
# Instead of a priority_queue, we just use a plain list
node_list = []
for char, freq in my_dict.items():
    node_list.append(Node(char, freq))

# 3. Build the tree using a manual loop
while len(node_list) > 1:

    # --- This block replaces `heapq.heappop()` ---
    # Find and remove the node with the smallest frequency
    # We use a 'key' to tell min() to look at the 'freq' attribute
    left_child = min(node_list, key=lambda node: node.freq)
    node_list.remove(left_child)

    # --- This block replaces the second `heapq.heappop()` ---
    # Find and remove the *next* smallest node
    right_child = min(node_list, key=lambda node: node.freq)
    node_list.remove(right_child)

    # --- This part is the same as before ---
    # Create a new internal node
    new_freq = left_child.freq + right_child.freq
    parent_node = Node('$', new_freq, left_child, right_child)

    # --- This replaces `heapq.heappush()` ---
    # Just add the new node back to the list.
    # It doesn't matter where, since we find the min manually.
    node_list.append(parent_node)

# The last remaining node is the root of the tree
root_node = node_list[0]

print("Root node frequency:", root_node.freq)

# --- Code to Generate Huffman Codes ---

huffman_codes = {}

def generate_codes(node, current_code):
    # If the node is a leaf node (it has a character)
    if node.char != '$':
        huffman_codes[node.char] = current_code
        return

    # Recurse left (assign '0')
    if node.left:
        generate_codes(node.left, current_code + "0")

    # Recurse right (assign '1')
    if node.right:
        generate_codes(node.right, current_code + "1")

# Start the code generation from the root
generate_codes(root_node, "")

print("\n--- Huffman Codes ---")
print(huffman_codes)

# --- Calculate Compressed Size ---
compressed_length = 0
for char in msg:
    compressed_length += len(huffman_codes[char])

print("\n--- Analysis ---")
print(f"Original Size:     {orignal_length} bits")
print(f"Compressed Size:   {compressed_length} bits")
print(f"Compression Ratio: {orignal_length / compressed_length:.2f}")
print(f"Space Saved:       {((orignal_length - compressed_length) / orignal_length) * 100:.2f}%")